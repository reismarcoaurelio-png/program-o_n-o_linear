<!DOCTYPE html>
<html lang="pt-BR">
<head>
<meta charset="UTF-8">
<title>Simplex KKT - Interativo e Automático</title>
<style>
body { font-family: Arial, sans-serif; padding: 20px; background:#f7f9fb; }
table { border-collapse: collapse; margin-top:10px; }
th, td { border:1px solid #999; padding:5px; text-align:center; }
th { background:#eee; }
button { padding:6px 10px; margin:5px; }
.status { margin-top:10px; padding:8px; border-radius:5px; }
.ok { background:#dcfce7; color:#065f46; }
.error { background:#fee2e2; color:#9b1c1c; }
</style>
</head>
<body>
<h1>Simplex KKT - Quadrático</h1>

<p>Problema:</p>
<pre>
Max z = -x1² +6x1 - 2x2² +8x2
Sujeito a: 2x1 + 4x2 ≤ 8
x1 ≥ 0, x2 ≥ 0
</pre>

<button id="autoSolve">Resolver Automaticamente</button>
<div id="iterations"></div>
<div class="status" id="feedback">Clique em "Resolver Automaticamente" para ver as iterações.</div>

<script>
// --- Variáveis ---
const varNames = ['x1','x2','x3','y1','y2','y3']; // x3 = folga, y's = complementares

// Base inicial: [x3, y1, y2]
let base = ['x3','y1','y2'];

// Sistema KKT inicial
let A = [
  [2,4,1,0,0,0],    // restrição original + folga
  [-2,0,0,1,0,-2],  // derivada w.r.t x1
  [0,-4,0,0,1,-4]   // derivada w.r.t x2
];
let b = [8,-6,-8];

// Salvar iterações
let iterations = [];

// --- Funções ---
function saveIteration(pivotRow=-1,pivotCol=-1){
  iterations.push({
    base:[...base],
    A:A.map(r=>[...r]),
    b:[...b],
    pivotRow,
    pivotCol
  });
}

// Pivot: atualiza tabela
function pivot(row,col){
  const pivotVal = A[row][col];
  for(let j=0;j<A[row].length;j++) A[row][j] /= pivotVal;
  b[row] /= pivotVal;
  for(let i=0;i<A.length;i++){
    if(i===row) continue;
    const factor = A[i][col];
    for(let j=0;j<A[i].length;j++) A[i][j] -= factor * A[row][j];
    b[i] -= factor * b[row];
  }
  base[row] = varNames[col];
  saveIteration(row,col);
}

// Variável que entra: mais negativa fora da base
function enteringVar(){
  let minVal = 0, idx = -1;
  for(let j=0;j<varNames.length;j++){
    if(!base.includes(varNames[j])){
      let val = 0;
      for(let i=0;i<A.length;i++) val += A[i][j];
      if(val < minVal){ minVal=val; idx=j;}
    }
  }
  return idx;
}

// Variável que sai: complementar da que entra
function leavingVar(enterCol){
  const enterVar = varNames[enterCol];
  for(let i=0;i<base.length;i++){
    const bv = base[i];
    const comp = bv.startsWith('x') ? 'y'+bv.slice(1) : 'x'+bv.slice(1);
    if(comp === enterVar) return i;
  }
  return -1;
}

// Iterar até ótimo
function solveAutomatic(){
  // reset
  base = ['x3','y1','y2'];
  A = [
    [2,4,1,0,0,0],
    [-2,0,0,1,0,-2],
    [0,-4,0,0,1,-4]
  ];
  b = [8,-6,-8];
  iterations=[];
  saveIteration();
  
  while(true){
    const enter = enteringVar();
    if(enter === -1) break; // ótimo
    const leave = leavingVar(enter);
    if(leave === -1) break; // não encontrou saída
    pivot(leave,enter);
  }
  
  renderIterations();
}

// Renderizar tabela
function renderIterations(){
  const area = document.getElementById('iterations');
  area.innerHTML='';
  iterations.forEach((it,i)=>{
    const div = document.createElement('div');
    div.innerHTML=`<strong>Iteração ${i+1}</strong>`;
    const tbl = document.createElement('table');
    const trh = document.createElement('tr');
    trh.innerHTML='<th>Base</th>'+varNames.map(v=>`<th>${v}</th>`).join('')+'<th>b</th>';
    tbl.appendChild(trh);
    for(let r=0;r<it.base.length;r++){
      const tr = document.createElement('tr');
      tr.innerHTML=`<td>${it.base[r]}</td>`+
        it.A[r].map(v=>`<td>${v.toFixed(4)}</td>`).join('')+
        `<td>${it.b[r].toFixed(4)}</td>`;
      tbl.appendChild(tr);
    }
    div.appendChild(tbl);
    area.appendChild(div);
  });
  document.getElementById('feedback').innerText='✅ Resolução automática completa.';
  document.getElementById('feedback').className='status ok';
}

// --- Eventos ---
document.getElementById('autoSolve').addEventListener('click', solveAutomatic);
</script>
</body>
</html>
